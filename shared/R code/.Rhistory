seq(0, 1, by = 0.05)
t<-seq(0, 1, by = 0.05)
sin(t)
plot(t,sin(t))
plot(t,sin(t/2))
plot(t,sin(t/5))
plot(t,sin(2*t))
plot(t,sin(3*t))
plot(t,cos(3*t))
plot(t,-sin(3*t))
plot(t,-sin(3*t)+1)
plot(t,sin(3*t))
plot(t,sin(2*t))
plot(t,3*t)
plot(t,3*t+1)
plot(t,-3*t+4)
plot(t,t+4)
n.t
plot(t,rep(3,length(t)))
## PLOT Gaussian Process data (class 3) ##
##########################################
rm(list = ls())
#### load packages & R code ####
library(mvtnorm);library(fda)
setwd('C:/Users/eugene/Desktop/SVM/shared/R code/')
source('eu/data_gen/multiclass/class3/gp.I.crss.linear.3.error.R')
source('eu/data_gen/multiclass/class3/gp.I.linear.K.error.R')
source('eu/data_gen/multiclass/class3/gp.I.nonlinear.3.error.R')
# Set Parameters
n <- 40; error <- 0.1; t <- seq(0, 1, by = 0.03); K<-3
# Generate data
data <- gp.I.crss.linear.3.error(n, error, t)
# Set Parameters
n <- 30; error <- 0.1; t <- seq(0, 1, by = 0.03); K<-3
# Generate data
data <- gp.I.crss.linear.3.error(n, error, t)
# index for 1, 2, 3, 4 class
idx.1 <- which(data$y == 1)
idx.2 <- which(data$y == 2)
# Check max value and plot the background
a <- c()
for (i in 1:n) a <- c(a, unlist(data$x[[i]]))
max(a)
plot(t, data$x[[1]], ylim = c(min(a),max(a)))
for (i in idx.1) lines(t, data$x[[i]], col = 1)
for (i in idx.2) lines(t, data$x[[i]], col = 2)
for (i in idx.3) lines(t, data$x[[i]], col = 3)
idx.3
idx.3 <- which(data$y == 3)
idx.3
for (i in idx.3) lines(t, data$x[[i]], col = 3)
# Set Parameters
n <- 30; error <- 0.1; t <- seq(0, 1, by = 0.03); K<-3; beta <- 1
# Generate data
# data <- gp.I.crss.linear.3.error(n, error, t)
data <- gp.I.linear.K.error(n, error, beta, K, t)
idx.1 <- which(data$y == 1)
idx.2 <- which(data$y == 2)
idx.3 <- which(data$y == 3)
# Check max value and plot the background
a <- c()
for (i in 1:n) a <- c(a, unlist(data$x[[i]]))
max(a)
plot(t, data$x[[1]], ylim = c(min(a),max(a)))
for (i in idx.1) lines(t, data$x[[i]], col = 1)
for (i in idx.2) lines(t, data$x[[i]], col = 2)
for (i in idx.3) lines(t, data$x[[i]], col = 3)
# Generate data
# data <- gp.I.crss.linear.3.error(n, error, t)
# data <- gp.I.linear.K.error(n, error, beta, K, t)
data <- gp.I.nonlinear.3.error(n, error, t)
idx.1 <- which(data$y == 1)
idx.2 <- which(data$y == 2)
idx.3 <- which(data$y == 3)
# Check max value and plot the background
a <- c()
for (i in 1:n) a <- c(a, unlist(data$x[[i]]))
max(a)
plot(t, data$x[[1]], ylim = c(min(a),max(a)))
for (i in idx.2) lines(t, data$x[[i]], col = 2)
for (i in idx.1) lines(t, data$x[[i]], col = 1)
for (i in idx.2) lines(t, data$x[[i]], col = 2)
for (i in idx.3) lines(t, data$x[[i]], col = 3)
# create Gaussian Process (1-dimension)
gp.I.nonlinear.3.error <- function(n, error, t = seq(0, 1, by = 0.05), seed = 1)
{
set.seed(seed)
K<-3
## Create multiple y
y <- rep(1,n)
quotient <- n %/% K
# Check the Division part
if (n %% K != 0) message(n, " is not divisible by ",K)
a <- c(1:n)
num <- seq(0, n, quotient)
label <- c(1:K)
for (i in 1:K){
y[(num[i]+1):num[i+1]] <- label[i]
}
# spatio temporal predictor
n.t <- length(t)
# covariance matrix of gaussian process
Sigma <- error*diag(n.t)
x.list <- as.list(1:n)
idx1 <- which(y==1)
idx2 <- which(y==2)
idx3 <- which(y==3)
for (i in idx1) {
mu.t <- z.t <- matrix(0, 1, n.t)
# mean vector of gaussian process
mu.t <- sin(3*t)
z.t <- rmvnorm(1, mu.t, Sigma)
x.list[[i]] <- z.t
}
for (i in idx2) {
mu.t <- z.t <- matrix(0, 1, n.t)
# mean vector of gaussian process
mu.t <- -sin(3*t)+1
z.t <- rmvnorm(1, mu.t, Sigma)
x.list[[i]] <- z.t
}
for (i in idx3) {
mu.t <- z.t <- matrix(0, 1, n.t)
# mean vector of gaussian process
mu.t <- sin(1.5*t)
z.t <- rmvnorm(1, mu.t, Sigma)
x.list[[i]] <- z.t
}
obj <- list(x = x.list, y = y, t = t)
return(obj)
}
# Generate data
# data <- gp.I.crss.linear.3.error(n, error, t)
# data <- gp.I.linear.K.error(n, error, beta, K, t)
data <- gp.I.nonlinear.3.error(n, error, t)
# index for 1, 2, 3, 4 class
idx.1 <- which(data$y == 1)
idx.2 <- which(data$y == 2)
idx.3 <- which(data$y == 3)
# Check max value and plot the background
a <- c()
for (i in 1:n) a <- c(a, unlist(data$x[[i]]))
max(a)
plot(t, data$x[[1]], ylim = c(min(a),max(a)))
for (i in idx.1) lines(t, data$x[[i]], col = 1)
for (i in idx.2) lines(t, data$x[[i]], col = 2)
for (i in idx.3) lines(t, data$x[[i]], col = 3)
iter<-1
n.test<-309
n.test<-30
result[[iter]] <- as.list(1:n.test)
# storage
result <- as.list(1:n.sim)
# set up
n.sim <- 50
# storage
result <- as.list(1:n.sim)
result[[iter]] <- as.list(1:n.test)
result
rm(list = ls())
# set up
n.sim <- 50
# storage
result <- as.list(1:n.sim)
result
iter<-1
result[[iter]]
n.test<-20
result[[iter]] <- as.list(1:n.test)
result
